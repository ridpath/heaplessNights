# JenkinsBreaker Exploit Module Interface

This directory contains standardized exploit modules for JenkinsBreaker. All exploit modules must conform to the interface defined in `__init__.py`.

## Module Structure

Each exploit module must follow this standardized structure:

```python
"""
CVE-YYYY-NNNNN: Module Title

Brief description of the vulnerability and exploit.
"""

import requests
from rich.console import Console
from exploits import ExploitMetadata, ExploitResult

console = Console()

CVE_ID = "CVE-YYYY-NNNNN"

METADATA = ExploitMetadata(
    cve_id=CVE_ID,
    name="Exploit Name",
    description="Brief description",
    affected_versions=["<= X.Y.Z", "Other version ranges"],
    mitre_attack=["T1190", "T1059"],
    severity="critical|high|medium|low",
    references=[
        "https://www.jenkins.io/security/advisory/...",
        "https://nvd.nist.gov/vuln/detail/CVE-..."
    ],
    requires_auth=True,
    requires_crumb=True,
    tags=["rce", "file-read", "etc"]
)


def check_vulnerable(tool, **kwargs):
    """
    Optional: Check if target is vulnerable before exploitation.
    
    Args:
        tool: JenkinsBreaker instance
        **kwargs: Additional arguments
        
    Returns:
        bool: True if vulnerable, False otherwise
    """
    # Implementation here
    return True


def run(tool, lhost=None, lport=None, **kwargs):
    """
    Execute the exploit.
    
    Args:
        tool: JenkinsBreaker instance with initialized session
        lhost: Listener host (if applicable)
        lport: Listener port (if applicable)
        **kwargs: Additional arguments
        
    Returns:
        ExploitResult: Structured result object
    """
    console.print(f"[yellow][*] Running {CVE_ID} exploit...[/yellow]")
    
    # Exploit implementation here
    
    return ExploitResult(
        exploit=CVE_ID,
        status="success|failed|error|not_vulnerable",
        details="Description of what happened",
        data={
            # Optional additional data
            "key": "value"
        }
    )
```

## Required Components

### 1. CVE_ID (Required)
A constant string identifying the CVE being exploited:
```python
CVE_ID = "CVE-2024-23897"
```

### 2. METADATA (Recommended)
An `ExploitMetadata` instance containing structured information about the exploit:

```python
METADATA = ExploitMetadata(
    cve_id=CVE_ID,
    name="Jenkins CLI Arbitrary File Read",
    description="Arbitrary file read via Jenkins CLI @file syntax",
    affected_versions=["<= 2.441", "<= 2.426.2 LTS"],
    mitre_attack=["T1190", "T1552.001"],
    severity="high",
    references=[
        "https://www.jenkins.io/security/advisory/2024-01-24/"
    ],
    requires_auth=False,
    requires_crumb=False,
    tags=["file-read", "information-disclosure", "cli"]
)
```

**Metadata Fields:**
- `cve_id`: CVE identifier
- `name`: Human-readable exploit name
- `description`: Brief description of the vulnerability
- `affected_versions`: List of affected Jenkins/plugin versions
- `mitre_attack`: List of MITRE ATT&CK technique IDs
- `severity`: critical, high, medium, or low
- `references`: List of URLs with more information
- `requires_auth`: Whether authentication is required
- `requires_crumb`: Whether CSRF crumb is required
- `tags`: List of tags for categorization

### 3. run() Function (Required)
Main exploit execution function:

```python
def run(tool, lhost=None, lport=None, **kwargs):
    """Execute the exploit."""
    # Implementation
    return ExploitResult(...)
```

**Parameters:**
- `tool`: JenkinsBreaker instance with session info (jenkins_url, auth, headers, proxies)
- `lhost`: Listener host for reverse shells (optional)
- `lport`: Listener port for reverse shells (optional)
- `**kwargs`: Additional arguments

**Returns:**
- `ExploitResult` instance with structured results

### 4. check_vulnerable() Function (Optional)
Pre-exploitation vulnerability check:

```python
def check_vulnerable(tool, **kwargs):
    """Check if target is vulnerable."""
    # Implementation
    return True  # or False
```

## ExploitResult Structure

The `run()` function must return an `ExploitResult` instance:

```python
from exploits import ExploitResult

result = ExploitResult(
    exploit="CVE-2024-23897",
    status="success",  # success, failed, error, not_vulnerable
    details="File read successfully via who-am-i endpoint",
    data={
        "file_path": "/etc/passwd",
        "content_length": 1024,
        "endpoint": "who-am-i"
    }
)
```

## Using the ExploitRegistry

The `ExploitRegistry` class provides dynamic module discovery and loading:

```python
from exploits import ExploitRegistry

registry = ExploitRegistry()

# Discover all modules
discovered = registry.discover_modules()

# Load all modules
loaded_count = registry.load_all_modules()

# Get a specific module
module = registry.get_module("cve_2024_23897")

# Get module by CVE ID
module = registry.get_by_cve_id("CVE-2024-23897")

# Execute a module
result = registry.execute_module("cve_2024_23897", tool, lhost="10.0.0.1", lport=9001)

# List all loaded modules
modules_info = registry.list_modules()

# Get modules by MITRE technique
modules = registry.get_modules_by_mitre("T1190")
```

## MITRE ATT&CK Mapping

All exploits should map to MITRE ATT&CK techniques. Common techniques:

| Technique ID | Description |
|--------------|-------------|
| T1190 | Exploit Public-Facing Application |
| T1059 | Command and Scripting Interpreter |
| T1059.007 | JavaScript |
| T1078 | Valid Accounts |
| T1555 | Credentials from Password Stores |
| T1552 | Unsecured Credentials |
| T1552.001 | Credentials In Files |
| T1552.004 | Private Keys |
| T1068 | Exploitation for Privilege Escalation |

## Validation

Validate your module with:

```bash
python validate_exploits.py
```

This will check:
- Required functions (run)
- CVE identifier (CVE_ID or cve)
- METADATA structure
- Interface compliance

## Module Naming Convention

Module files must follow the naming pattern:
```
exploits/cve_YYYY_NNNNN.py
```

Examples:
- `cve_2024_23897.py` for CVE-2024-23897
- `cve_2019_1003029.py` for CVE-2019-1003029

## Error Handling

Always include proper error handling in your exploit:

```python
try:
    r = requests.post(url, auth=tool.auth, verify=False, timeout=10)
    if r.status_code == 200:
        return ExploitResult(
            exploit=CVE_ID,
            status="success",
            details="Exploit successful"
        )
    else:
        return ExploitResult(
            exploit=CVE_ID,
            status="failed",
            details=f"HTTP {r.status_code}"
        )
except Exception as e:
    console.print(f"[red][!] Error: {e}[/red]")
    return ExploitResult(
        exploit=CVE_ID,
        status="error",
        details=str(e)
    )
```

## Accessing Jenkins Session Info

The `tool` parameter provides access to:
- `tool.jenkins_url`: Base URL of Jenkins instance
- `tool.auth`: Authentication tuple (username, password)
- `tool.custom_headers`: Custom HTTP headers
- `tool.proxies`: Proxy configuration

## Dry-Run Mode

Modules should respect the `--dry-run` flag if passed in kwargs:

```python
def run(tool, **kwargs):
    if kwargs.get('dry_run'):
        console.print("[yellow][*] Dry-run mode: simulating exploit[/yellow]")
        return ExploitResult(
            exploit=CVE_ID,
            status="success",
            details="Dry-run simulation completed"
        )
    # Normal execution
```

## Testing

Test your module against the Jenkins Lab environment:

```bash
cd jenkins-lab
docker-compose up -d

cd ..
python JenkinsBreaker.py --url http://localhost:8080 \
    --exploit-cve CVE-YYYY-NNNNN \
    --lhost 127.0.0.1 \
    --lport 9001
```

## Example: Creating a New Module

1. Create file `exploits/cve_2020_2100.py`
2. Add module header and imports
3. Define CVE_ID and METADATA
4. Implement check_vulnerable() (optional)
5. Implement run() with proper error handling
6. Return ExploitResult with structured data
7. Validate with `python validate_exploits.py`
8. Test against Jenkins Lab

## Logging

Use the console for user-facing output and logging for audit trails:

```python
import logging

logging.info(f"Attempting exploit {CVE_ID}")
console.print("[yellow][*] Running exploit...[/yellow]")
```

## Best Practices

1. Always validate input parameters
2. Use timeouts on all HTTP requests
3. Return structured ExploitResult objects
4. Include MITRE ATT&CK mappings
5. Document affected versions
6. Add references to official advisories
7. Implement check_vulnerable() when possible
8. Use proper error handling
9. Test against Jenkins Lab
10. Follow naming conventions
