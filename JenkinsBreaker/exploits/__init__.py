"""
JenkinsBreaker Exploit Module Interface

This module provides a standardized interface for all CVE exploit modules.
Each exploit module must conform to this interface for proper loading and execution.
"""

import os
import importlib
import inspect
from typing import Dict, List, Callable, Optional, Any
from dataclasses import dataclass, field
from rich.console import Console

console = Console()


@dataclass
class ExploitMetadata:
    """Standard metadata structure for exploit modules."""
    cve_id: str
    name: str
    description: str
    affected_versions: List[str]
    mitre_attack: List[str]
    severity: str
    references: List[str] = field(default_factory=list)
    requires_auth: bool = True
    requires_crumb: bool = False
    tags: List[str] = field(default_factory=list)


@dataclass
class ExploitResult:
    """Standard result structure for exploit execution."""
    exploit: str
    status: str
    details: str
    data: Optional[Dict[str, Any]] = None
    timestamp: Optional[str] = None


class ExploitInterface:
    """
    Base interface that all exploit modules should follow.
    
    Each exploit module must implement:
    - CVE_ID: str constant
    - METADATA: ExploitMetadata instance
    - check_vulnerable(tool, **kwargs): Optional vulnerability check
    - run(tool, **kwargs): Main exploit execution
    """
    
    CVE_ID: str = ""
    METADATA: ExploitMetadata = None
    
    @staticmethod
    def check_vulnerable(tool, **kwargs) -> bool:
        """
        Optional: Check if target is vulnerable before exploitation.
        
        Args:
            tool: JenkinsBreaker instance
            **kwargs: Additional arguments
            
        Returns:
            bool: True if vulnerable, False otherwise
        """
        return True
    
    @staticmethod
    def run(tool, **kwargs) -> ExploitResult:
        """
        Execute the exploit.
        
        Args:
            tool: JenkinsBreaker instance with initialized session
            **kwargs: Additional arguments (lhost, lport, etc.)
            
        Returns:
            ExploitResult: Structured result object
        """
        raise NotImplementedError("Exploit module must implement run() method")


class ExploitRegistry:
    """
    Dynamic exploit module discovery and loading system.
    """
    
    def __init__(self, exploits_dir: Optional[str] = None):
        """
        Initialize the exploit registry.
        
        Args:
            exploits_dir: Path to exploits directory (defaults to this file's directory)
        """
        self.exploits_dir = exploits_dir or os.path.dirname(__file__)
        self._modules: Dict[str, Any] = {}
        self._metadata: Dict[str, ExploitMetadata] = {}
        
    def discover_modules(self) -> List[str]:
        """
        Discover all exploit modules in the exploits directory.
        
        Returns:
            List[str]: List of discovered module names
        """
        discovered = []
        
        if not os.path.exists(self.exploits_dir):
            console.print(f"[red][!] Exploits directory not found: {self.exploits_dir}[/red]")
            return discovered
        
        for filename in os.listdir(self.exploits_dir):
            if filename.startswith("cve_") and filename.endswith(".py"):
                module_name = filename[:-3]
                discovered.append(module_name)
        
        return discovered
    
    def load_module(self, module_name: str) -> bool:
        """
        Load a single exploit module and validate its interface.
        
        Args:
            module_name: Name of the module to load (without .py)
            
        Returns:
            bool: True if loaded successfully, False otherwise
        """
        try:
            module_path = f"exploits.{module_name}"
            module = importlib.import_module(module_path)
            
            if not self._validate_module(module, module_name):
                return False
            
            self._modules[module_name] = module
            
            if hasattr(module, 'METADATA'):
                self._metadata[module_name] = module.METADATA
            elif hasattr(module, 'cve'):
                self._metadata[module_name] = ExploitMetadata(
                    cve_id=module.cve,
                    name=module_name,
                    description=getattr(module, 'description', f"Exploit for {module.cve}"),
                    affected_versions=getattr(module, 'affected_versions', []),
                    mitre_attack=getattr(module, 'mitre_attack', []),
                    severity=getattr(module, 'severity', 'medium'),
                    requires_auth=getattr(module, 'requires_auth', True),
                    requires_crumb=getattr(module, 'requires_crumb', False),
                    tags=getattr(module, 'tags', [])
                )
            
            return True
            
        except ImportError as e:
            console.print(f"[red][!] Failed to import {module_name}: {e}[/red]")
            return False
        except Exception as e:
            console.print(f"[red][!] Error loading {module_name}: {e}[/red]")
            return False
    
    def _validate_module(self, module: Any, module_name: str) -> bool:
        """
        Validate that a module conforms to the exploit interface.
        
        Args:
            module: Loaded module object
            module_name: Name of the module
            
        Returns:
            bool: True if valid, False otherwise
        """
        if not hasattr(module, 'run'):
            console.print(f"[yellow][!] Module {module_name} missing required 'run' function[/yellow]")
            return False
        
        if not callable(module.run):
            console.print(f"[yellow][!] Module {module_name} 'run' is not callable[/yellow]")
            return False
        
        if not (hasattr(module, 'cve') or hasattr(module, 'CVE_ID')):
            console.print(f"[yellow][!] Module {module_name} missing CVE identifier[/yellow]")
            return False
        
        return True
    
    def load_all_modules(self) -> int:
        """
        Discover and load all exploit modules.
        
        Returns:
            int: Number of successfully loaded modules
        """
        discovered = self.discover_modules()
        loaded_count = 0
        
        console.print(f"[cyan][*] Discovered {len(discovered)} exploit modules[/cyan]")
        
        for module_name in discovered:
            if self.load_module(module_name):
                loaded_count += 1
                cve_id = self.get_cve_id(module_name)
                console.print(f"[green][+] Loaded {module_name} ({cve_id})[/green]")
            else:
                console.print(f"[red][-] Failed to load {module_name}[/red]")
        
        console.print(f"[cyan][*] Successfully loaded {loaded_count}/{len(discovered)} modules[/cyan]")
        return loaded_count
    
    def get_module(self, module_name: str) -> Optional[Any]:
        """
        Get a loaded module by name.
        
        Args:
            module_name: Name of the module
            
        Returns:
            Module object or None if not found
        """
        return self._modules.get(module_name)
    
    def get_metadata(self, module_name: str) -> Optional[ExploitMetadata]:
        """
        Get metadata for a loaded module.
        
        Args:
            module_name: Name of the module
            
        Returns:
            ExploitMetadata or None if not found
        """
        return self._metadata.get(module_name)
    
    def get_cve_id(self, module_name: str) -> str:
        """
        Get CVE ID for a module.
        
        Args:
            module_name: Name of the module
            
        Returns:
            str: CVE ID or 'Unknown'
        """
        module = self.get_module(module_name)
        if module:
            if hasattr(module, 'CVE_ID'):
                return module.CVE_ID
            elif hasattr(module, 'cve'):
                return module.cve
        return "Unknown"
    
    def list_modules(self) -> List[Dict[str, str]]:
        """
        List all loaded modules with their metadata.
        
        Returns:
            List[Dict]: List of module information dictionaries
        """
        modules_info = []
        
        for module_name, metadata in self._metadata.items():
            modules_info.append({
                "name": module_name,
                "cve_id": metadata.cve_id,
                "description": metadata.description,
                "severity": metadata.severity,
                "mitre_attack": ", ".join(metadata.mitre_attack) if metadata.mitre_attack else "N/A",
                "affected_versions": ", ".join(metadata.affected_versions) if metadata.affected_versions else "N/A"
            })
        
        return modules_info
    
    def get_by_cve_id(self, cve_id: str) -> Optional[Any]:
        """
        Get a module by its CVE ID.
        
        Args:
            cve_id: CVE identifier (e.g., CVE-2024-23897)
            
        Returns:
            Module object or None if not found
        """
        cve_id_normalized = cve_id.upper().replace("-", "_")
        
        for module_name, module in self._modules.items():
            module_cve = self.get_cve_id(module_name).upper().replace("-", "_")
            if module_cve == cve_id_normalized:
                return module
        
        return None
    
    def get_modules_by_mitre(self, mitre_id: str) -> List[Any]:
        """
        Get all modules that map to a specific MITRE ATT&CK technique.
        
        Args:
            mitre_id: MITRE ATT&CK technique ID (e.g., T1190)
            
        Returns:
            List[Any]: List of matching modules
        """
        matching_modules = []
        
        for module_name, metadata in self._metadata.items():
            if mitre_id in metadata.mitre_attack:
                matching_modules.append(self._modules[module_name])
        
        return matching_modules
    
    def execute_module(self, module_name: str, tool: Any, **kwargs) -> ExploitResult:
        """
        Execute an exploit module with standardized error handling.
        
        Args:
            module_name: Name of the module to execute
            tool: JenkinsBreaker instance
            **kwargs: Additional arguments for the exploit
            
        Returns:
            ExploitResult: Result of the exploit execution
        """
        module = self.get_module(module_name)
        
        if not module:
            return ExploitResult(
                exploit=module_name,
                status="failed",
                details=f"Module {module_name} not loaded"
            )
        
        try:
            if hasattr(module, 'check_vulnerable'):
                if not module.check_vulnerable(tool, **kwargs):
                    return ExploitResult(
                        exploit=self.get_cve_id(module_name),
                        status="not_vulnerable",
                        details="Target does not appear to be vulnerable"
                    )
            
            result = module.run(tool, **kwargs)
            
            if isinstance(result, dict):
                return ExploitResult(
                    exploit=result.get('exploit', self.get_cve_id(module_name)),
                    status=result.get('status', 'unknown'),
                    details=result.get('details', ''),
                    data=result.get('data')
                )
            elif isinstance(result, ExploitResult):
                return result
            else:
                return ExploitResult(
                    exploit=self.get_cve_id(module_name),
                    status="unknown",
                    details=str(result)
                )
                
        except Exception as e:
            console.print(f"[red][!] Error executing {module_name}: {e}[/red]")
            return ExploitResult(
                exploit=self.get_cve_id(module_name),
                status="error",
                details=f"Execution error: {str(e)}"
            )


MITRE_ATTACK_MAPPING = {
    "T1190": "Exploit Public-Facing Application",
    "T1059": "Command and Scripting Interpreter",
    "T1059.007": "Command and Scripting Interpreter: JavaScript",
    "T1078": "Valid Accounts",
    "T1555": "Credentials from Password Stores",
    "T1552": "Unsecured Credentials",
    "T1552.001": "Credentials In Files",
    "T1552.004": "Private Keys",
    "T1068": "Exploitation for Privilege Escalation",
    "T1210": "Exploitation of Remote Services",
    "T1203": "Exploitation for Client Execution",
    "T1574": "Hijack Execution Flow",
    "T1574.002": "DLL Side-Loading",
    "T1055": "Process Injection",
    "T1569": "System Services",
    "T1569.002": "Service Execution"
}


def get_mitre_description(technique_id: str) -> str:
    """
    Get the description of a MITRE ATT&CK technique.
    
    Args:
        technique_id: MITRE technique ID
        
    Returns:
        str: Description or technique ID if not found
    """
    return MITRE_ATTACK_MAPPING.get(technique_id, technique_id)


__all__ = [
    'ExploitInterface',
    'ExploitMetadata',
    'ExploitResult',
    'ExploitRegistry',
    'MITRE_ATTACK_MAPPING',
    'get_mitre_description'
]
